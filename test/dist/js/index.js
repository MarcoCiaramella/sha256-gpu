(()=>{"use strict";var e,n,a,s,r={10:(e,n,a)=>{function s(e,n){const a=new ArrayBuffer(4*n);return new Uint8Array(a).set(e),new Uint32Array(a)}a.d(n,{n:()=>i});class r{#e;#n;async init(){var e;return this.#e=await async function(){const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(e)return await e.requestDevice();throw"No adapter"}(),this.#n=this.#e.createComputePipeline({compute:{module:this.#e.createShaderModule({code:(e=this.#e,`\n// SHA-256 for 32-bit aligned messages\n\nfn swap_endianess32(val: u32) -> u32 {\n    return ((val>>24u) & 0xffu) | ((val>>8u) & 0xff00u) | ((val<<8u) & 0xff0000u) | ((val<<24u) & 0xff000000u);\n}\n\nfn shw(x: u32, n: u32) -> u32 {\n    return (x << (n & 31u)) & 0xffffffffu;\n}\n\nfn r(x: u32, n: u32) -> u32 {\n    return (x >> n) | shw(x, 32u - n);\n}\n\nfn g0(x: u32) -> u32 {\n    return r(x, 7u) ^ r(x, 18u) ^ (x >> 3u);\n}\n\nfn g1(x: u32) -> u32 {\n    return r(x, 17u) ^ r(x, 19u) ^ (x >> 10u);\n}\n\nfn s0(x: u32) -> u32 {\n    return r(x, 2u) ^ r(x, 13u) ^ r(x, 22u);\n}\n\nfn s1(x: u32) -> u32 {\n    return r(x, 6u) ^ r(x, 11u) ^ r(x, 25u);\n}\n\nfn maj(a: u32, b: u32, c: u32) -> u32 {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n\nfn ch(e: u32, f: u32, g: u32) -> u32 {\n    return (e & f) ^ ((~e) & g);\n}\n\n@group(0) @binding(0) var<storage, read_write> messages: array<u32>;\n@group(0) @binding(1) var<storage, read> num_messages: u32;\n@group(0) @binding(2) var<storage, read> message_sizes: array<u32>;\n@group(0) @binding(3) var<storage, read_write> hashes: array<u32>;\n\n@compute @workgroup_size(${e.limits.maxComputeWorkgroupSizeX})\nfn sha256(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\n    let index = global_id.x;\n    if (index >= num_messages) {\n        return;\n    }\n    let message_base_index = index * message_sizes[1];\n    let hash_base_index = index * (256u / 32u);\n\n    // == padding == //\n\n    messages[message_base_index + message_sizes[0]] = 0x00000080u;\n    for (var i = message_sizes[0] + 1; i < message_sizes[1] - 2; i++){\n        messages[message_base_index + i] = 0x00000000u;\n    }\n    messages[message_base_index + message_sizes[1] - 2] = 0;\n    messages[message_base_index + message_sizes[1] - 1] = swap_endianess32(message_sizes[0] * 32u);\n\n    // == processing == //\n\n    hashes[hash_base_index] = 0x6a09e667u;\n    hashes[hash_base_index + 1] = 0xbb67ae85u;\n    hashes[hash_base_index + 2] = 0x3c6ef372u;\n    hashes[hash_base_index + 3] = 0xa54ff53au;\n    hashes[hash_base_index + 4] = 0x510e527fu;\n    hashes[hash_base_index + 5] = 0x9b05688cu;\n    hashes[hash_base_index + 6] = 0x1f83d9abu;\n    hashes[hash_base_index + 7] = 0x5be0cd19u;\n\n    let k = array<u32,64>(\n        0x428a2f98u, 0x71374491u, 0xb5c0fbcfu, 0xe9b5dba5u, 0x3956c25bu, 0x59f111f1u, 0x923f82a4u, 0xab1c5ed5u,\n        0xd807aa98u, 0x12835b01u, 0x243185beu, 0x550c7dc3u, 0x72be5d74u, 0x80deb1feu, 0x9bdc06a7u, 0xc19bf174u,\n        0xe49b69c1u, 0xefbe4786u, 0x0fc19dc6u, 0x240ca1ccu, 0x2de92c6fu, 0x4a7484aau, 0x5cb0a9dcu, 0x76f988dau,\n        0x983e5152u, 0xa831c66du, 0xb00327c8u, 0xbf597fc7u, 0xc6e00bf3u, 0xd5a79147u, 0x06ca6351u, 0x14292967u,\n        0x27b70a85u, 0x2e1b2138u, 0x4d2c6dfcu, 0x53380d13u, 0x650a7354u, 0x766a0abbu, 0x81c2c92eu, 0x92722c85u,\n        0xa2bfe8a1u, 0xa81a664bu, 0xc24b8b70u, 0xc76c51a3u, 0xd192e819u, 0xd6990624u, 0xf40e3585u, 0x106aa070u,\n        0x19a4c116u, 0x1e376c08u, 0x2748774cu, 0x34b0bcb5u, 0x391c0cb3u, 0x4ed8aa4au, 0x5b9cca4fu, 0x682e6ff3u,\n        0x748f82eeu, 0x78a5636fu, 0x84c87814u, 0x8cc70208u, 0x90befffau, 0xa4506cebu, 0xbef9a3f7u, 0xc67178f2u\n    );\n\n    let num_chunks = (message_sizes[1] * 32u) / 512u;\n    for (var i = 0u; i < num_chunks; i++){\n        let chunk_index = i * (512u/32u);\n        var w = array<u32,64>();\n        for (var j = 0u; j < 16u; j++){\n            w[j] = swap_endianess32(messages[message_base_index + chunk_index + j]);\n        }\n        for (var j = 16u; j < 64u; j++){\n            w[j] = w[j - 16u] + g0(w[j - 15u]) + w[j - 7u] + g1(w[j - 2u]);\n        }\n        var a = hashes[hash_base_index];\n        var b = hashes[hash_base_index + 1];\n        var c = hashes[hash_base_index + 2];\n        var d = hashes[hash_base_index + 3];\n        var e = hashes[hash_base_index + 4];\n        var f = hashes[hash_base_index + 5];\n        var g = hashes[hash_base_index + 6];\n        var h = hashes[hash_base_index + 7];\n        for (var j = 0u; j < 64u; j++){\n            let t2 = s0(a) + maj(a, b, c);\n            let t1 = h + s1(e) + ch(e, f, g) + k[j] + w[j];\n            h = g;\n            g = f;\n            f = e;\n            e = d + t1;\n            d = c;\n            c = b;\n            b = a;\n            a = t1 + t2;\n        }\n        hashes[hash_base_index] += a;\n        hashes[hash_base_index + 1] += b;\n        hashes[hash_base_index + 2] += c;\n        hashes[hash_base_index + 3] += d;\n        hashes[hash_base_index + 4] += e;\n        hashes[hash_base_index + 5] += f;\n        hashes[hash_base_index + 6] += g;\n        hashes[hash_base_index + 7] += h;\n    }\n    hashes[hash_base_index] = swap_endianess32(hashes[hash_base_index]);\n    hashes[hash_base_index + 1] = swap_endianess32(hashes[hash_base_index + 1]);\n    hashes[hash_base_index + 2] = swap_endianess32(hashes[hash_base_index + 2]);\n    hashes[hash_base_index + 3] = swap_endianess32(hashes[hash_base_index + 3]);\n    hashes[hash_base_index + 4] = swap_endianess32(hashes[hash_base_index + 4]);\n    hashes[hash_base_index + 5] = swap_endianess32(hashes[hash_base_index + 5]);\n    hashes[hash_base_index + 6] = swap_endianess32(hashes[hash_base_index + 6]);\n    hashes[hash_base_index + 7] = swap_endianess32(hashes[hash_base_index + 7]);\n}`)}),entryPoint:"sha256"},layout:"auto"}),this}get device(){return this.#e}get computePipeline(){return this.#n}}let t;async function i(e){!function(e){for(const n of e){if(n.length!==e[0].length)throw"Messages must have the same size";if(n.length%4!=0)throw"Message must be 32-bit aligned"}}(e),t=t||await(new r).init();const n=function(e,n){const a=Math.ceil(n.length/e.limits.maxComputeWorkgroupSizeX);if(a>e.limits.maxComputeWorkgroupsPerDimension)throw`Input array too large. Max size is ${e.limits.maxComputeWorkgroupsPerDimension*e.limits.maxComputeWorkgroupSizeX}.`;return a}(t.device,e),a=function(e){const n=8*e.length;return new Uint32Array([n/32,(n+(512-(n+1+64)%512+1+64))/32])}(e[0]),i=new Uint32Array(a[1]*e.length);let u=0;for(const n of e){const e=s(n,a[1]);i.set(e,u),u+=e.length}const h=t.device.createBuffer({mappedAtCreation:!0,size:i.byteLength,usage:GPUBufferUsage.STORAGE});new Uint32Array(h.getMappedRange()).set(i),h.unmap();const o=t.device.createBuffer({mappedAtCreation:!0,size:Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE});new Uint32Array(o.getMappedRange()).set([e.length]),o.unmap();const c=t.device.createBuffer({mappedAtCreation:!0,size:a.byteLength,usage:GPUBufferUsage.STORAGE});new Uint32Array(c.getMappedRange()).set(a),c.unmap();const x=32*e.length,f=t.device.createBuffer({size:x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),d=t.device.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:{buffer:o}},{binding:2,resource:{buffer:c}},{binding:3,resource:{buffer:f}}]}),_=t.device.createCommandEncoder(),b=_.beginComputePass();b.setPipeline(t.computePipeline),b.setBindGroup(0,d),b.dispatchWorkgroups(n),b.end();const g=t.device.createBuffer({size:x,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});_.copyBufferToBuffer(f,0,g,0,x);const p=_.finish();return t.device.queue.submit([p]),await g.mapAsync(GPUMapMode.READ),new Uint8Array(g.getMappedRange())}},601:(e,n,a)=>{a.a(e,(async(e,n)=>{try{var s=a(10);async function r(){const e=[new Uint8Array([1,0,0,0]),new Uint8Array([2,0,0,0]),new Uint8Array([3,0,0,0]),new Uint8Array([4,0,0,0]),new Uint8Array([5,0,0,0]),new Uint8Array([6,0,0,0]),new Uint8Array([7,0,0,0]),new Uint8Array([8,0,0,0]),new Uint8Array([9,0,0,0])],n=await(0,s.n)(e);for(let e=0;e<n.length;e+=32)console.log(n.subarray(e,e+32).reduce(((e,n)=>e+n.toString(16).padStart(2,"0")),""))}async function t(){const e=[];for(let n=0;n<131e3;n++){const n=new Uint8Array(576);n.fill(1),e.push(n)}const n=(new Date).getTime();await(0,s.n)(e);const a=(new Date).getTime();console.log("time "+(a-n)+"ms")}async function i(){const e=[new Uint8Array([1,0,0,0]),new Uint8Array([2,0,0,0]),new Uint8Array([3,0,0,0]),new Uint8Array([4,0,0,0]),new Uint8Array([5,0,0,0]),new Uint8Array([6,0,0,0]),new Uint8Array([7,0,0,0]),new Uint8Array([8,0,0,0]),new Uint8Array([9,0,0,0])];async function n(e){const n=await crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(n)).map((e=>e.toString(16).padStart(2,"0"))).join("")}const a=await(0,s.n)(e);let r=[];for(let e=0;e<a.length;e+=32)r.push(a.subarray(e,e+32).reduce(((e,n)=>e+n.toString(16).padStart(2,"0")),""));let t=[];for(const a of e)t.push(await n(a));console.log(JSON.stringify(r)===JSON.stringify(t))}async function u(){const e=[];for(let n=0;n<131e3;n++){const n=new Uint8Array(576);n.fill(1),e.push(n)}let n=(new Date).getTime();await(0,s.n)(e);let a=(new Date).getTime();console.log("GPU time "+(a-n)+"ms"),n=(new Date).getTime();for(const n of e)await crypto.subtle.digest("SHA-256",n);a=(new Date).getTime(),console.log("CPU time "+(a-n)+"ms")}await r(),await r(),await r(),await t(),await t(),await t(),await i(),await i(),await i(),await u(),await u(),await u(),n()}catch(h){n(h)}}),1)}},t={};function i(e){var n=t[e];if(void 0!==n)return n.exports;var a=t[e]={exports:{}};return r[e](a,a.exports,i),a.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",n="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",a="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",s=e=>{e&&!e.d&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},i.a=(r,t,i)=>{var u;i&&((u=[]).d=1);var h,o,c,x=new Set,f=r.exports,d=new Promise(((e,n)=>{c=n,o=e}));d[n]=f,d[e]=e=>(u&&e(u),x.forEach(e),d.catch((e=>{}))),r.exports=d,t((r=>{var t;h=(r=>r.map((r=>{if(null!==r&&"object"==typeof r){if(r[e])return r;if(r.then){var t=[];t.d=0,r.then((e=>{i[n]=e,s(t)}),(e=>{i[a]=e,s(t)}));var i={};return i[e]=e=>e(t),i}}var u={};return u[e]=e=>{},u[n]=r,u})))(r);var i=()=>h.map((e=>{if(e[a])throw e[a];return e[n]})),o=new Promise((n=>{(t=()=>n(i)).r=0;var a=e=>e!==u&&!x.has(e)&&(x.add(e),e&&!e.d&&(t.r++,e.push(t)));h.map((n=>n[e](a)))}));return t.r?o:i()}),(e=>(e?c(d[a]=e):o(f),s(u)))),u&&(u.d=0)},i.d=(e,n)=>{for(var a in n)i.o(n,a)&&!i.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},i.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),i(601)})();